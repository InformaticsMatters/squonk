// Minishift Gradle Control Tasks
//
// Tasks to starts, configure and delete a Minishift instance.
// Main tasks are:
//
// - startMinishift
// - deleteMinishift
//
// Alan Christie
// November 2017

ext {

    minishift_cpus = '2'
    minishift_memory = '4GB'
    minishift_disk_size = '20GB'
    minishift_vm_driver = 'virtualbox'
    minishift_url = ''

    open_shift_project = 'squonk'
    open_shift_project_display_name = 'Squonk'

    template_path = 'templates'

    pause_time = 2000

}

// Returns True if a local Minishift instance appears to be running.
// This relies on what `minishift status` issues to <stdout>
def minishiftIsRunning = { ->

    def ms_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
            'minishift status'
        standardOutput = ms_out
    }
    return ms_out.toString().trim().startsWith('Minishift:  Running')

}

// Returns True if the named Pod appears to be running.
// This relies on what `oc get po` issues to <stdout>
def podIsRunning = { String pod_name ->

    def oc_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
            "oc get po -l name=$pod_name"
        standardOutput = oc_out
    }
    // We simply look for ' 1/1 '...
    def pod_matcher = (oc_out.toString() =~ /\s1\/1\s/)
    return pod_matcher.size() > 0

}

// Starts a Minishift instance
// by invoking `minishift start` using the `minishift` variables
// defined in the `ext` block above.
task minishiftStart(type: Exec) {

    description 'Starts a local Minishift instance'

    commandLine 'bash', '-c',
        "minishift start" +
        " --cpus $minishift_cpus" +
        " --memory $minishift_memory" +
        " --disk-size $minishift_disk_size" +
        " --vm-driver $minishift_vm_driver"

    // Keep output, we might need it later...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift start failed; see output above")
        }
        def addr_matcher = (standardOutput.toString() =~ /console at:\s+(http\S+)/)
        minishift_url = addr_matcher[0][1]
    }

}

// Deletes a Minithsift instance.
// It does this by invoking `minishift delete --force`.
task minishiftDelete(type: Exec) {

    description 'Deletes a local Minishift instance'

    commandLine 'bash', '-c',
        'minishift delete --force'

    // Keep output, we might need it later...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift delete failed; see output above")
        }
    }

}

task openShiftLoginDeveloper(type: Exec) {

    description 'Login as the OpenShift developer'

    commandLine 'bash', '-c',
        'oc login -u developer'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as developer.'
    }

}

task openShiftLoginSystemAdmin(type: Exec) {

    description 'Login as the OpenShift developer'

    commandLine 'bash', '-c',
        'oc login -u system:admin'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as system:admin.'
    }

}

task openShiftAddClusterRoleToUser(type: Exec) {

    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-cluster-role-to-user cluster-admin -z default'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added cluster role to user.'
    }

}

task openShiftAddSccToGroup(type: Exec) {

    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-scc-to-group anyuid system:authenticated'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added SCC to group.'
    }

}

task openShiftCreateSquonkProject(type: Exec) {

    description 'Creates the Squonk OpenShift project'

    commandLine 'bash', '-c',
        "oc new-project $open_shift_project" +
        " --display-name $open_shift_project_display_name"

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

}

task openShiftDeleteMyProject(type: Exec) {

    description 'Deletes the built-in MyProject project'

    commandLine 'bash', '-c',
        'oc delete project myproject --force'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

}

// Process and loads the Squonk `secrets`.
task processSecretsTemplate(type: Exec) {

    description 'Loads the Squonk secrets template'

    doFirst {
        logger.lifecycle 'Loading infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-secrets.yaml | oc create -f -'

    // Keep output, we might need it later...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the secrets already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Squonk Secrets already loaded.'
        } else {
            logger.lifecycle 'Loaded Squonk Secrets.'
        }

    }

}

// Process and loads the Squonk `infra` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processInfraTemplate(type: Exec) {

    description 'Loads the Squonk infrastructure template'

    doFirst {
        logger.lifecycle 'Loading infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-infra.yaml | oc create -f -'

    // Keep output, we might need it later...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Infrastructure already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. rabbitmq and postgres
            logger.lifecycle 'Waiting for Infrastructure Pods...'
            while (!podIsRunning('rabbitmq') || !podIsRunning('postgres')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Infrastructure.'
        }

    }

}

// Process and loads the Squonk `app` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processAppTemplate(type: Exec) {

    description 'Loads the Squonk application template'

    doFirst {
        logger.lifecycle 'Loading application...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-app.yaml | oc create -f -'

    // Keep output, we might need it later...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Application already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. core, cell etc.
            logger.lifecycle 'Waiting for Application Pods...'
            while (!podIsRunning('portal') ||
                   !podIsRunning('cellexecutor') ||
                   !podIsRunning('coreservices') ||
                   !podIsRunning('chemservices-basic')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Application.'
        }

    }

}

// Processes the suite of known templates, waiting for the
// successful start-up of each Pod.
// Templates consists of `secrets`, `infra` and `app`.
task processTemplates {

    description 'Processes the Squonk templates creating their Pods'

    doLast {
        processSecretsTemplate.execute()
        processInfraTemplate.execute()
        processAppTemplate.execute()
    }

}

// Called after a Minishift instance has started
// and configures it. This consists of things like
// setting Pod and SA permissions and creating the
// Squonk project.
task configureOpenShift {

    description 'Configures a running OpenShift instance'

    doLast {

        // Basically do all the fiddly stuff you need to do
        // before you can load any of the application templates.
        openShiftAddSccToGroup.execute()
        openShiftAddClusterRoleToUser.execute()
        openShiftLoginDeveloper.execute()
        openShiftDeleteMyProject.execute()
        openShiftCreateSquonkProject.execute()
    }

}

// Starts, configures and installs the initial set of Pods
// into a new Minishift instance. If Minishift appears to be running
// this task does nothing.
task startMinishift {

    description 'Starts and configures Minishift (if one does not already exist)'

    doLast {

        // Starts a Minishift instance (if not already running).
        // If started,  Minishift URL is reported to the command-line.
        logger.lifecycle 'Starting Minishift...'
        minishiftStart.execute()
        logger.lifecycle 'Minishift started.'
        logger.quiet 'Minishift started on ' + minishift_url

        // Configures the Minishift instance
        // This includes creating projects, setting permissions etc.
        logger.lifecycle 'Configuring...'
        configureOpenShift.execute()
        logger.lifecycle 'Configured.'

        // Processes the known Squonk templates,
        // waiting until completion.
        logger.lifecycle 'Processing templates...'
        processTemplates.execute()
        logger.lifecycle 'Processed.'

    }

    onlyIf {
        ! minishiftIsRunning()
    }

}

// Deletes a Minithsift instance if one exists.
// It does this by invoking `minishift delete --force`.
task deleteMinishift {

    description 'Tries to delete the Minishift instance (if it exists)'

    doLast {

        logger.lifecycle 'Stopping Minishift...'
        minishiftDelete.execute()
        logger.lifecycle 'Minishift stopped.'

    }

    onlyIf {
        minishiftIsRunning()
    }

}
