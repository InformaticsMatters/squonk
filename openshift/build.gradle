// Minishift Gradle Control Tasks
//
// Tasks to exercise a local Minishift instance.
// Main tasks are:
//
// -    configureOpenShift
//
// To load and then delete the entire application.
// These tasks run to completion....
//
// -    processAll
// -    deleteAll
//
// Or, you can control individual sections fo the application with:
//
// -    processApp
// -    deleteApp
//
// Or run each template separately...
//
// -    processSecretsTemplate
// -    processInfraTemplate
// -    processAppTemplate
//
// Note: The user is expected to have started a minishift instance and
//       setup the system variables to enable the use of the docker registry
//       that's part of the Minishift. So, you are expected to have run...
//
//       $ minishift start               - plus define CPU, Memory & disk-space
//       $ eval $(minishift docker-env)
//
// Alan Christie
// November 2017

ext {

    minishift_cpus = '2'
    minishift_memory = '4GB'
    minishift_disk_size = '20GB'
    minishift_vm_driver = 'virtualbox'
    minishift_url = ''

    open_shift_project = 'squonk'
    open_shift_project_display_name = 'Squonk'

    template_path = 'templates'

    pause_time = 2000

}

// Returns True if a local Minishift instance appears to be running.
// This relies on what `minishift status` issues to <stdout>.
def minishiftIsRunning = {

    def ms_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
                'minishift status'
        standardOutput = ms_out
    }
    return ms_out.toString().contains('Running')

}

// Returns True if a local Minishift environment appears to be set.
// This relies on whether the environment variable DOCKER_HOST
// is set.
def envIsSet = {

    def result = exec {
        commandLine 'bash', '-c', 'env | grep DOCKER_HOST'
        // Soak-up any output...
        standardOutput = new ByteArrayOutputStream()
        errorOutput = standardOutput
        ignoreExitValue = true
    }
    return result.getExitValue() == 0

}

// Returns True if the named Pod appears to be running.
// This relies on what `oc get po` issues to <stdout>.
def podIsRunning = { String pod_name ->

    def oc_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
            "oc get po -l name=$pod_name"
        standardOutput = oc_out
        errorOutput = standardOutput
    }
    // We simply look for a pod count that's not ' 0/N '...
    def pod_matcher = (oc_out.toString() =~ /\s[1..9]\d*\/\d+\s/)
    return pod_matcher.size() > 0

}

task openShiftLoginDeveloper(type: Exec) {

    description 'Login as the OpenShift developer'

    commandLine 'bash', '-c',
        'oc login -u developer'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as developer.'
    }

}

task openShiftLoginSystemAdmin(type: Exec) {

    description 'Login as the OpenShift developer'

    commandLine 'bash', '-c',
        'oc login -u system:admin'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as system:admin.'
    }

}

task openShiftAddClusterRoleToUser(type: Exec) {

    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-cluster-role-to-user cluster-admin -z default'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added cluster role to user.'
    }

}

task openShiftAddSccToGroup(type: Exec) {

    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-scc-to-group anyuid system:authenticated'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added SCC to group.'
    }

}

task openShiftCreateSquonkProject(type: Exec) {

    description 'Creates the Squonk OpenShift project'

    commandLine 'bash', '-c',
        "oc new-project $open_shift_project" +
        " --display-name $open_shift_project_display_name"

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

}

task openShiftDeleteMyProject(type: Exec) {

    description 'Deletes the built-in MyProject project'

    commandLine 'bash', '-c',
        'oc delete project myproject --force'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

}

// Process and loads the Squonk `secrets`.
task processSecrets(type: Exec) {

    description 'Loads the Squonk secrets template'

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading secrets...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-secrets.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the secrets already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Squonk Secrets already loaded.'
        } else {
            logger.lifecycle 'Loaded Squonk Secrets.'
        }

    }

}

// Process and loads the Squonk `infra` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processInfra(type: Exec) {

    description 'Loads the Squonk infrastructure template'

    dependsOn processSecrets

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-infra.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Infrastructure already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. rabbitmq and postgres
            logger.lifecycle 'Waiting for Infrastructure Pods...'
            while (!podIsRunning('rabbitmq') || !podIsRunning('postgres')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Infrastructure.'
        }

    }

}

// Process and loads the Squonk `app` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processApp(type: Exec) {

    description 'Loads the Squonk application template'

    dependsOn processSecrets
    dependsOn processInfra
    tasks.findByName('processInfra').mustRunAfter processSecrets

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading application...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-app.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Application already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. core, cell etc.
            logger.lifecycle 'Waiting for Application Pods...'
            while (!podIsRunning('portal') ||
                   !podIsRunning('cellexecutor') ||
                   !podIsRunning('coreservices') ||
                   !podIsRunning('chemservices-basic')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Application.'
        }

    }

}

// Deletes the Squonk `secrets`.
task deleteSecrets(type: Exec) {

    description 'Deletes the Squonk secrets'

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk Sectets...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete secrets --selector template=squonk-secrets'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        logger.lifecycle 'Deleted Squonk Secrets.'

    }

}

// Deletes the Squonk `app`.
task deleteInfra(type: Exec) {

    description 'Deletes the Squonk Infrastructure'

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk Infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete all,cm,pvc,secrets --selector template=squonk-infra'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        logger.lifecycle 'Deleted Squonk Infrastructure.'

    }

}

// Deletes the Squonk `app`.
task deleteApp(type: Exec) {

    description 'Deletes the Squonk secrets'

    doFirst {
        if (!minishiftIsRunning) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk App...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete all,cm,pvc,routes,secrets --selector template=squonk-app'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        logger.lifecycle 'Deleted Squonk App.'

    }

}

// Processes the suite of known templates, waiting for the
// successful start-up of each Pod.
// Templates consists of `secrets`, `infra` and `app`.
task processAll {

    description 'Processes the Squonk templates creating their Pods'

    dependsOn processSecrets
    dependsOn processInfra
    dependsOn processApp
    tasks.findByName('processInfra').mustRunAfter processSecrets
    tasks.findByName('processApp').mustRunAfter processSecrets

}

// Deletes everything created by the suite of known templates.
// Templates consists of `secrets`, `infra` and `app`.
task deleteAll {

    description 'Deletes Squonk'

    dependsOn deleteSecrets
    dependsOn deleteInfra
    dependsOn deleteApp

}

// Called after a Minishift instance has started
// and configures it. This consists of things like
// setting Pod and SA permissions and creating the
// Squonk project.
task configureOpenShift {

    description 'Configures a running OpenShift instance'

    doLast {

        // Basically do all the fiddly stuff you need to do
        // before you can load any of the application templates.
        openShiftAddSccToGroup.execute()
        openShiftAddClusterRoleToUser.execute()
        openShiftLoginDeveloper.execute()
        openShiftDeleteMyProject.execute()
        openShiftCreateSquonkProject.execute()
    }

}

// The following tasks (to the end fo the file) are experimental and involve
// the automatic start-up of a local minishift environment. They are known to
// work (at the time of writing) but until we have a strategy for utilising
// the system environment variables that are set by `minishift docker-env`
// we cannot build from within a minishift environment started by gradle
// (because gradle nor its tasks can set system environment vraibles).
// Calling `eval $(minishift docker-env)` in a task does not appear to work as
// expected - i.e. the variables are not available to other tasks.
//
// One thought is to invoke `minishift docker-env` and capture the created
// environment variables into Gradle variables that can then be used in
// `environment` settings for the dependent tasks.
//
// ABC (6 Nov 2017)

// Starts a Minishift instance
// by invoking `minishift start` using the `minishift` variables
// defined in the `ext` block above.
task start(type: Exec) {

    description 'Starts a local Minishift instance'

    commandLine 'bash', '-c',
            "minishift start" +
                    " --cpus $minishift_cpus" +
                    " --memory $minishift_memory" +
                    " --disk-size $minishift_disk_size" +
                    " --vm-driver $minishift_vm_driver"

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift start failed; see output above")
        }
        def addr_matcher = (standardOutput.toString() =~ /console at:\s+(http\S+)/)
        minishift_url = addr_matcher[0][1]
    }

}

// Deletes a Minithsift instance.
// It does this by invoking `minishift delete --force`.
task delete(type: Exec) {

    description 'Deletes a local Minishift instance'

    commandLine 'bash', '-c',
            'minishift delete --force'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift delete failed; see output above")
        }
    }

}

// Starts, configures and installs the initial set of Pods
// into a new Minishift instance. Depending on your internet connection speeds
// this can be a time-consuming task (maybe up to 14/15 minutes).
// If Minishift appears to be running this task does nothing.
task minishiftStart {

    description 'Starts and configures Minishift (if one does not already exist)'

    doLast {

        // Starts a Minishift instance (if not already running).
        // If started,  Minishift URL is reported to the command-line.
        logger.lifecycle 'Starting Minishift...'
        minishiftStart.execute()
        logger.lifecycle 'Minishift started.'
        logger.quiet 'Minishift started on ' + minishift_url

        // Configures the Minishift instance
        // This includes creating projects, setting permissions etc.
        logger.lifecycle 'Configuring...'
        configureOpenShift.execute()
        logger.lifecycle 'Configured.'

        // Processes the known Squonk templates,
        // waiting until completion.
        logger.lifecycle 'Processing templates...'
        processTemplates.execute()
        logger.lifecycle 'Processed.'

    }

    onlyIf {
        ! minishiftIsRunning()
    }

}

// Deletes a Minithsift instance if one exists.
// It does this by invoking `minishift delete --force`.
task minishiftDelete {

    description 'Tries to delete the Minishift instance (if it exists)'

    doLast {

        logger.lifecycle 'Stopping Minishift...'
        minishiftDelete.execute()
        logger.lifecycle 'Minishift stopped.'

    }

    onlyIf {
        minishiftIsRunning()
    }

}
