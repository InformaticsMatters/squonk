// Minishift Gradle Control Tasks
//
// Tasks to exercise a local Minishift instance.
// Main tasks are:
//
// -    configureOpenShift
//
// Then, to load and then delete the entire application.
// These tasks run to completion....
//
// -    processAll
// -    deleteAll
//
// Or, you can control individual sections of the application with
// the sub-tasks. The app is handled by the following for example...
//
// -    processApp
// -    deleteApp
//
// You can deploy (re-deploy) the OpenShift images with the tasks:
//
// -    deployCellExecutor
// -    deployChemServices
// -    deployCoreServices
//
// Note: The user is expected to have started a minishift instance and
//       setup the system variables to enable the use of the docker registry
//       that's part of the Minishift. So, you are expected to have run...
//
//       $ minishift start               - plus define cpus, memory & disk-size
//       $ eval $(minishift docker-env)
//
// Alan Christie
// November 2017

ext {

    minishift_cpus = '2'
    minishift_memory = '4GB'
    minishift_disk_size = '20GB'
    minishift_vm_driver = 'virtualbox'
    minishift_url = ''

    open_shift_project = 'squonk'
    open_shift_project_display_name = 'Squonk'

    // Relative path to our OpenShift templates.
    template_path = 'templates'

    // Pause period between command execution status checks
    pause_time = 1000

    // A variable defining a deployment name
    // used in the `deploy' task.
    deployment_name = null

}

// Returns True if a local Minishift instance appears to be running.
// This relies on what `minishift status` issues to <stdout>.
def minishiftIsRunning = {

    def ms_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
                'minishift status'
        standardOutput = ms_out
    }
    return ms_out.toString().contains('Running')

}

// Returns True if a local Minishift environment appears to be set.
// This relies on whether the environment variable DOCKER_HOST
// is set.
def envIsSet = {

    def result = exec {
        commandLine 'bash', '-c', 'env | grep DOCKER_HOST'
        // Soak-up any output...
        standardOutput = new ByteArrayOutputStream()
        errorOutput = standardOutput
        ignoreExitValue = true
    }
    return result.getExitValue() == 0

}

// Returns True if the named Pod appears to be running.
// This relies on what `oc get po` issues to <stdout>.
def podIsRunning = { String pod_name ->

    def oc_out = new ByteArrayOutputStream()
    exec {
        commandLine 'bash', '-c',
            "oc get po -l name=$pod_name"
        standardOutput = oc_out
        errorOutput = standardOutput
    }

    // We simply make sure there's only one example of ' N/N '
    // and it's not ' 0/N '...
    def pod_matcher = (oc_out.toString() =~ /(?m)\s(\d+)\/\d+\s/)
    return pod_matcher.count == 1 && pod_matcher[0][1] != "0"

}

task openShiftLoginDeveloper(type: Exec) {

    group 'OpenShift'
    description 'Login as the OpenShift developer'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Logging in as developer...'
    }

    commandLine 'bash', '-c',
        'oc login -u developer'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as developer.'
    }

}

task openShiftLoginSystemAdmin(type: Exec) {

    group 'OpenShift'
    description 'Login as the OpenShift system:admin'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Logging in as system:admin...'
    }

    commandLine 'bash', '-c',
        'oc login -u system:admin'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Logged in as system:admin.'
    }

}

task openShiftAddClusterRoleToUser(type: Exec) {

    group 'OpenShift'
    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-cluster-role-to-user cluster-admin -z default'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added cluster role to user.'
    }

}

task openShiftAddSccToGroup(type: Exec) {

    group 'OpenShift'
    description 'Sets cluster admin for default service account'

    doFirst {
        openShiftLoginSystemAdmin.execute()
    }

    commandLine 'bash', '-c',
        'oc adm policy add-scc-to-group anyuid system:authenticated'

    // Soak-up any output...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput

    doLast {
        logger.lifecycle 'Added SCC to group.'
    }

}

task openShiftCreateSquonkProject(type: Exec) {

    group 'OpenShift'
    description 'Creates the Squonk OpenShift project'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Creating Squonk project...'
    }

    commandLine 'bash', '-c',
        "oc new-project $open_shift_project" +
        " --display-name $open_shift_project_display_name"

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the project already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Creation failed; see output above")
            }
            logger.lifecycle 'Squonk project already exists.'
        } else {
            logger.lifecycle 'Created Squonk project.'
        }

    }

}

// Process and loads the Squonk `secrets`.
task processSecrets(type: Exec) {

    group 'OpenShift'
    description 'Loads the Squonk secrets template'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading secrets...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-secrets.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the secrets already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Squonk Secrets already loaded.'
        } else {
            logger.lifecycle 'Loaded Squonk Secrets.'
        }

    }

}

// Process and loads the Squonk `infra` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processInfra(type: Exec) {

    group 'OpenShift'
    description 'Loads the Squonk infrastructure template'

    dependsOn processSecrets

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-infra.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Infrastructure already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. rabbitmq and postgres
            logger.lifecycle 'Waiting for Infrastructure Pods...'
            while (!podIsRunning('rabbitmq') || !podIsRunning('postgres')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Infrastructure.'
        }

    }

}

// Process and loads the Squonk `app` Pods, Services, etc.,
// Waiting until each Pod claims to be running.
task processApp(type: Exec) {

    group 'OpenShift'
    description 'Loads the Squonk application template'

    dependsOn processSecrets
    dependsOn processInfra
    processInfra.mustRunAfter processSecrets

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Loading application...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
        'oc process -f squonk-app.yaml | oc create -f -'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {

        // Did something go wrong?
        if (execResult.exitValue != 0) {
            // It might have failed because the services already exist
            def output = standardOutput.toString()
            def matcher = (output =~ /already exists/)
            if (matcher.size() == 0) {
                logger.lifecycle output
                throw new GradleException("Load failed; see output above")
            }
            logger.lifecycle 'Application already loaded.'
        } else {
            // Looks like we processed the template successfully.
            // Wait for services...
            // i.e. core, cell etc.
            logger.lifecycle 'Waiting for Application Pods...'
            while (!podIsRunning('portal') ||
                   !podIsRunning('cellexecutor') ||
                   !podIsRunning('coreservices') ||
                   !podIsRunning('chemservices-basic')) {
                sleep(pause_time)
            }
            logger.lifecycle 'Loaded Application.'
        }

    }

}

// Deletes the Squonk `secrets`.
task deleteSecrets(type: Exec) {

    group 'OpenShift'
    description 'Deletes the Squonk secrets'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk Sectets...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete secrets --selector template=squonk-secrets'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        logger.lifecycle 'Deleted Squonk Secrets.'
    }

}

// Deletes the Squonk `app`.
task deleteInfra(type: Exec) {

    group 'OpenShift'
    description 'Deletes the Squonk Infrastructure (postgres, rabbitmq)'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk Infrastructure...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete all,cm,pvc,secrets --selector template=squonk-infra'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        logger.lifecycle 'Deleted Squonk Infrastructure.'
    }

}

// Deletes the Squonk `app`.
task deleteApp(type: Exec) {

    group 'OpenShift'
    description 'Deletes the Squonk application components (cell, core, chem, portal)'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        logger.lifecycle 'Deleteing Squonk App...'
    }

    workingDir template_path
    commandLine 'bash', '-c',
            'oc delete all,cm,pvc,routes,secrets --selector template=squonk-app'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        logger.lifecycle 'Deleted Squonk App.'
    }

}

// Deploys (redeploys) an OpenShift service, waiting for completion.
// the service/image name needs to be put into the 'deployment_name' ext variable.
// See 'deployCellExecutor'
task deploy(type: Exec) {

    group 'OpenShift'
    description '(Re)Deploys a Deployment Config named in the deployment_name variable'

    doFirst {
        if (!minishiftIsRunning()) {
            throw new GradleException("Oops - minishift does not appear to be running!")
        }
        if (!podIsRunning(deployment_name)) {
            throw new GradleException("Cannot deploy unless the Pod is already running!")
        }
        logger.lifecycle "Deploying ${deployment_name}..."

        workingDir template_path
        commandLine 'bash', '-c',
                "oc deploy ${deployment_name} --latest"

    }

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        // Did something go wrong?
        if (execResult.exitValue != 0) {
            throw new GradleException("Load failed; see output above")
        } else {
            // Looks like we deployed successfully.
            // Wait for the Pod bounce...
            logger.lifecycle 'Waiting for the deployment...'
            while (podIsRunning(deployment_name)) {
                sleep(pause_time)
            }
            while (!podIsRunning(deployment_name)) {
                sleep(pause_time)
            }
        }

        logger.lifecycle "Deployed ${deployment_name}."
    }

}

task deployCellExecutor {

    group 'OpenShift'
    description 'Invokes the deploy task for "cellexecutor"'

    doFirst {
        deployment_name = 'cellexecutor'
        deploy.execute()
    }

}

task deployChemServices {

    group 'OpenShift'
    description 'Invokes the deploy task for "chemservices-basic"'

    doFirst {
        deployment_name = 'chemservices-basic'
        deploy.execute()
    }

}

task deployCoreServices {

    group 'OpenShift'
    description 'Invokes the deploy task for "coreservices"'

    doFirst {
        deployment_name = 'coreservices'
        deploy.execute()
    }

}

// Processes the suite of known templates, waiting for the
// successful start-up of each Pod.
// Templates consists of `secrets`, `infra` and `app`.
task processAll {

    group 'OpenShift'
    description 'Processes the Squonk templates (secrets, infra and app) creating their Pods'

    dependsOn processSecrets
    dependsOn processInfra
    dependsOn processApp
    processInfra.mustRunAfter processSecrets
    processApp.mustRunAfter processSecrets

}

// Deletes everything created by the suite of known templates.
// Templates consists of `secrets`, `infra` and `app`.
task deleteAll {

    group 'OpenShift'
    description 'Deletes Squonk (app, infra and secrets)'

    dependsOn deleteSecrets
    dependsOn deleteInfra
    dependsOn deleteApp

}

// Called after a Minishift instance has started
// and configures it. This consists of things like
// setting Pod and SA permissions and creating the
// Squonk project.
task configureOpenShift {

    group 'OpenShift'
    description 'Configures a running OpenShift instance'

    dependsOn openShiftAddSccToGroup
    dependsOn openShiftAddClusterRoleToUser
    dependsOn openShiftLoginDeveloper
    dependsOn openShiftCreateSquonkProject
    openShiftLoginDeveloper.mustRunAfter openShiftAddSccToGroup
    openShiftLoginDeveloper.mustRunAfter openShiftAddClusterRoleToUser
    openShiftCreateSquonkProject.mustRunAfter openShiftLoginDeveloper

}

// The following tasks (to the end fo the file) are experimental and involve
// the automatic start-up of a local minishift environment. They are known to
// work (at the time of writing) but until we have a strategy for utilising
// the system environment variables that are set by `minishift docker-env`
// we cannot build from within a minishift environment started by gradle
// (because gradle nor its tasks can set system environment vraibles).
// Calling `eval $(minishift docker-env)` in a task does not appear to work as
// expected - i.e. the variables are not available to other tasks.
//
// One thought is to invoke `minishift docker-env` and capture the created
// environment variables into Gradle variables that can then be used in
// `environment` settings for the dependent tasks.
//
// ABC (6 Nov 2017)

// Starts a Minishift instance
// by invoking `minishift start` using the `minishift` variables
// defined in the `ext` block above.
task miniStart(type: Exec) {

    group 'OpenShift'
    description 'Starts a local Minishift instance'

    commandLine 'bash', '-c',
            "minishift start" +
                    " --cpus $minishift_cpus" +
                    " --memory $minishift_memory" +
                    " --disk-size $minishift_disk_size" +
                    " --vm-driver $minishift_vm_driver"

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift start failed; see output above")
        }
        def addr_matcher = (standardOutput.toString() =~ /console at:\s+(http\S+)/)
        minishift_url = addr_matcher[0][1]
    }

}

// Removes (deletes) a Minithsift instance.
// It does this by invoking `minishift delete --force`.
task miniDelete(type: Exec) {

    group 'OpenShift'
    description 'Deletes a local Minishift instance'

    commandLine 'bash', '-c',
            'minishift delete --force'

    // Keep output, we'll use it later if the task fails...
    standardOutput = new ByteArrayOutputStream()
    errorOutput = standardOutput
    ignoreExitValue = true

    doLast {
        if (execResult.exitValue != 0) {
            logger.lifecycle standardOutput.toString()
            throw new GradleException("Minishift delete failed; see output above")
        }
    }

}

// Starts, configures and installs the initial set of Pods
// into a new Minishift instance. Depending on your internet connection speeds
// this can be a time-consuming task (maybe up to 14/15 minutes).
// If Minishift appears to be running this task does nothing.
task minishiftStart {

    group 'OpenShift'
    description 'Starts and configures Minishift (if one does not already exist)'

    doLast {

        // Starts a Minishift instance (if not already running).
        // If started,  Minishift URL is reported to the command-line.
        logger.lifecycle 'Starting Minishift...'
        miniStart.execute()
        logger.lifecycle 'Minishift started.'
        logger.quiet 'Minishift started on ' + minishift_url

        // Configures the Minishift instance
        // This includes creating projects, setting permissions etc.
        logger.lifecycle 'Configuring...'
        configureOpenShift.execute()
        logger.lifecycle 'Configured.'

        // Processes the known Squonk templates,
        // waiting until completion.
        logger.lifecycle 'Processing templates...'
        processAll.execute()
        logger.lifecycle 'Processed.'

    }

    onlyIf {
        ! minishiftIsRunning()
    }

}

// Deletes a Minithsift instance if one exists.
// It does this by invoking `minishift delete --force`.
task minishiftDelete {

    group 'OpenShift'
    description 'Tries to delete the Minishift instance (if it exists)'

    doLast {

        logger.lifecycle 'Stopping Minishift...'
        miniDelete.execute()
        logger.lifecycle 'Minishift stopped.'

    }

    onlyIf {
        minishiftIsRunning()
    }

}
